// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const countContenders = `-- name: CountContenders :one
SELECT COUNT(*)
FROM contender
WHERE contest_id = ?
`

func (q *Queries) CountContenders(ctx context.Context, contestID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContenders, contestID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteContender = `-- name: DeleteContender :exec
DELETE FROM contender
WHERE id = ?
`

func (q *Queries) DeleteContender(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteContender, id)
	return err
}

const deleteTick = `-- name: DeleteTick :exec
DELETE
FROM tick
WHERE id = ?
`

func (q *Queries) DeleteTick(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteTick, id)
	return err
}

const getCompClass = `-- name: GetCompClass :one
SELECT comp_class.id, comp_class.organizer_id, comp_class.contest_id, comp_class.name, comp_class.description, comp_class.color, comp_class.time_begin, comp_class.time_end
FROM comp_class
WHERE id = ?
`

type GetCompClassRow struct {
	CompClass CompClass
}

func (q *Queries) GetCompClass(ctx context.Context, id int32) (GetCompClassRow, error) {
	row := q.db.QueryRowContext(ctx, getCompClass, id)
	var i GetCompClassRow
	err := row.Scan(
		&i.CompClass.ID,
		&i.CompClass.OrganizerID,
		&i.CompClass.ContestID,
		&i.CompClass.Name,
		&i.CompClass.Description,
		&i.CompClass.Color,
		&i.CompClass.TimeBegin,
		&i.CompClass.TimeEnd,
	)
	return i, err
}

const getCompClassesByContest = `-- name: GetCompClassesByContest :many
SELECT comp_class.id, comp_class.organizer_id, comp_class.contest_id, comp_class.name, comp_class.description, comp_class.color, comp_class.time_begin, comp_class.time_end
FROM comp_class
WHERE contest_id = ?
`

type GetCompClassesByContestRow struct {
	CompClass CompClass
}

func (q *Queries) GetCompClassesByContest(ctx context.Context, contestID int32) ([]GetCompClassesByContestRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompClassesByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompClassesByContestRow
	for rows.Next() {
		var i GetCompClassesByContestRow
		if err := rows.Scan(
			&i.CompClass.ID,
			&i.CompClass.OrganizerID,
			&i.CompClass.ContestID,
			&i.CompClass.Name,
			&i.CompClass.Description,
			&i.CompClass.Color,
			&i.CompClass.TimeBegin,
			&i.CompClass.TimeEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContender = `-- name: GetContender :one
SELECT contender.id, contender.organizer_id, contender.contest_id, contender.registration_code, contender.name, contender.club, contender.class_id, contender.entered, contender.disqualified, contender.withdrawn_from_finals, score.contender_id, score.timestamp, score.score, score.placement, score.finalist, score.rank_order FROM contender
JOIN score ON score.contender_id = id
WHERE id = ?
`

type GetContenderRow struct {
	Contender Contender
	Score     Score
}

func (q *Queries) GetContender(ctx context.Context, id int32) (GetContenderRow, error) {
	row := q.db.QueryRowContext(ctx, getContender, id)
	var i GetContenderRow
	err := row.Scan(
		&i.Contender.ID,
		&i.Contender.OrganizerID,
		&i.Contender.ContestID,
		&i.Contender.RegistrationCode,
		&i.Contender.Name,
		&i.Contender.Club,
		&i.Contender.ClassID,
		&i.Contender.Entered,
		&i.Contender.Disqualified,
		&i.Contender.WithdrawnFromFinals,
		&i.Score.ContenderID,
		&i.Score.Timestamp,
		&i.Score.Score,
		&i.Score.Placement,
		&i.Score.Finalist,
		&i.Score.RankOrder,
	)
	return i, err
}

const getContenderByCode = `-- name: GetContenderByCode :one
SELECT contender.id, contender.organizer_id, contender.contest_id, contender.registration_code, contender.name, contender.club, contender.class_id, contender.entered, contender.disqualified, contender.withdrawn_from_finals, score.contender_id, score.timestamp, score.score, score.placement, score.finalist, score.rank_order FROM contender
JOIN score ON score.contender_id = id
WHERE registration_code = ?
`

type GetContenderByCodeRow struct {
	Contender Contender
	Score     Score
}

func (q *Queries) GetContenderByCode(ctx context.Context, registrationCode string) (GetContenderByCodeRow, error) {
	row := q.db.QueryRowContext(ctx, getContenderByCode, registrationCode)
	var i GetContenderByCodeRow
	err := row.Scan(
		&i.Contender.ID,
		&i.Contender.OrganizerID,
		&i.Contender.ContestID,
		&i.Contender.RegistrationCode,
		&i.Contender.Name,
		&i.Contender.Club,
		&i.Contender.ClassID,
		&i.Contender.Entered,
		&i.Contender.Disqualified,
		&i.Contender.WithdrawnFromFinals,
		&i.Score.ContenderID,
		&i.Score.Timestamp,
		&i.Score.Score,
		&i.Score.Placement,
		&i.Score.Finalist,
		&i.Score.RankOrder,
	)
	return i, err
}

const getContendersByCompClass = `-- name: GetContendersByCompClass :many
SELECT contender.id, contender.organizer_id, contender.contest_id, contender.registration_code, contender.name, contender.club, contender.class_id, contender.entered, contender.disqualified, contender.withdrawn_from_finals, score.contender_id, score.timestamp, score.score, score.placement, score.finalist, score.rank_order FROM contender
JOIN score ON score.contender_id = id
WHERE class_id = ?
`

type GetContendersByCompClassRow struct {
	Contender Contender
	Score     Score
}

func (q *Queries) GetContendersByCompClass(ctx context.Context, classID sql.NullInt32) ([]GetContendersByCompClassRow, error) {
	rows, err := q.db.QueryContext(ctx, getContendersByCompClass, classID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContendersByCompClassRow
	for rows.Next() {
		var i GetContendersByCompClassRow
		if err := rows.Scan(
			&i.Contender.ID,
			&i.Contender.OrganizerID,
			&i.Contender.ContestID,
			&i.Contender.RegistrationCode,
			&i.Contender.Name,
			&i.Contender.Club,
			&i.Contender.ClassID,
			&i.Contender.Entered,
			&i.Contender.Disqualified,
			&i.Contender.WithdrawnFromFinals,
			&i.Score.ContenderID,
			&i.Score.Timestamp,
			&i.Score.Score,
			&i.Score.Placement,
			&i.Score.Finalist,
			&i.Score.RankOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContendersByContest = `-- name: GetContendersByContest :many
SELECT contender.id, contender.organizer_id, contender.contest_id, contender.registration_code, contender.name, contender.club, contender.class_id, contender.entered, contender.disqualified, contender.withdrawn_from_finals, score.contender_id, score.timestamp, score.score, score.placement, score.finalist, score.rank_order FROM contender
JOIN score ON score.contender_id = id
WHERE contest_id = ?
`

type GetContendersByContestRow struct {
	Contender Contender
	Score     Score
}

func (q *Queries) GetContendersByContest(ctx context.Context, contestID int32) ([]GetContendersByContestRow, error) {
	rows, err := q.db.QueryContext(ctx, getContendersByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContendersByContestRow
	for rows.Next() {
		var i GetContendersByContestRow
		if err := rows.Scan(
			&i.Contender.ID,
			&i.Contender.OrganizerID,
			&i.Contender.ContestID,
			&i.Contender.RegistrationCode,
			&i.Contender.Name,
			&i.Contender.Club,
			&i.Contender.ClassID,
			&i.Contender.Entered,
			&i.Contender.Disqualified,
			&i.Contender.WithdrawnFromFinals,
			&i.Score.ContenderID,
			&i.Score.Timestamp,
			&i.Score.Score,
			&i.Score.Placement,
			&i.Score.Finalist,
			&i.Score.RankOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContest = `-- name: GetContest :one
SELECT contest.id, contest.organizer_id, contest.protected, contest.series_id, contest.name, contest.description, contest.location, contest.final_enabled, contest.qualifying_problems, contest.finalists, contest.rules, contest.grace_period, MIN(cc.time_begin) AS time_begin, MAX(cc.time_end) AS time_end
FROM contest
LEFT JOIN comp_class cc ON cc.contest_id = contest.id
WHERE contest.id = ?
`

type GetContestRow struct {
	Contest   Contest
	TimeBegin interface{}
	TimeEnd   interface{}
}

func (q *Queries) GetContest(ctx context.Context, id int32) (GetContestRow, error) {
	row := q.db.QueryRowContext(ctx, getContest, id)
	var i GetContestRow
	err := row.Scan(
		&i.Contest.ID,
		&i.Contest.OrganizerID,
		&i.Contest.Protected,
		&i.Contest.SeriesID,
		&i.Contest.Name,
		&i.Contest.Description,
		&i.Contest.Location,
		&i.Contest.FinalEnabled,
		&i.Contest.QualifyingProblems,
		&i.Contest.Finalists,
		&i.Contest.Rules,
		&i.Contest.GracePeriod,
		&i.TimeBegin,
		&i.TimeEnd,
	)
	return i, err
}

const getContestsCurrentlyRunningOrByStartTime = `-- name: GetContestsCurrentlyRunningOrByStartTime :many
SELECT contest.id, contest.organizer_id, contest.protected, contest.series_id, contest.name, contest.description, contest.location, contest.final_enabled, contest.qualifying_problems, contest.finalists, contest.rules, contest.grace_period, MIN(cc.time_begin) AS time_begin, MAX(cc.time_end) AS time_end
FROM contest
JOIN comp_class cc ON cc.contest_id = contest.id
GROUP BY contest.id
HAVING
    NOW() BETWEEN MIN(cc.time_begin) AND MAX(cc.time_end)
	OR MIN(cc.time_begin) BETWEEN ? AND ?
`

type GetContestsCurrentlyRunningOrByStartTimeRow struct {
	Contest   Contest
	TimeBegin interface{}
	TimeEnd   interface{}
}

func (q *Queries) GetContestsCurrentlyRunningOrByStartTime(ctx context.Context) ([]GetContestsCurrentlyRunningOrByStartTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, getContestsCurrentlyRunningOrByStartTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContestsCurrentlyRunningOrByStartTimeRow
	for rows.Next() {
		var i GetContestsCurrentlyRunningOrByStartTimeRow
		if err := rows.Scan(
			&i.Contest.ID,
			&i.Contest.OrganizerID,
			&i.Contest.Protected,
			&i.Contest.SeriesID,
			&i.Contest.Name,
			&i.Contest.Description,
			&i.Contest.Location,
			&i.Contest.FinalEnabled,
			&i.Contest.QualifyingProblems,
			&i.Contest.Finalists,
			&i.Contest.Rules,
			&i.Contest.GracePeriod,
			&i.TimeBegin,
			&i.TimeEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblem = `-- name: GetProblem :one
SELECT problem.id, problem.organizer_id, problem.contest_id, problem.number, problem.hold_color_primary, problem.hold_color_secondary, problem.name, problem.description, problem.points, problem.flash_bonus
FROM problem
WHERE id = ?
`

type GetProblemRow struct {
	Problem Problem
}

func (q *Queries) GetProblem(ctx context.Context, id int32) (GetProblemRow, error) {
	row := q.db.QueryRowContext(ctx, getProblem, id)
	var i GetProblemRow
	err := row.Scan(
		&i.Problem.ID,
		&i.Problem.OrganizerID,
		&i.Problem.ContestID,
		&i.Problem.Number,
		&i.Problem.HoldColorPrimary,
		&i.Problem.HoldColorSecondary,
		&i.Problem.Name,
		&i.Problem.Description,
		&i.Problem.Points,
		&i.Problem.FlashBonus,
	)
	return i, err
}

const getProblemsByContest = `-- name: GetProblemsByContest :many
SELECT problem.id, problem.organizer_id, problem.contest_id, problem.number, problem.hold_color_primary, problem.hold_color_secondary, problem.name, problem.description, problem.points, problem.flash_bonus
FROM problem
WHERE contest_id = ?
`

type GetProblemsByContestRow struct {
	Problem Problem
}

func (q *Queries) GetProblemsByContest(ctx context.Context, contestID int32) ([]GetProblemsByContestRow, error) {
	rows, err := q.db.QueryContext(ctx, getProblemsByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemsByContestRow
	for rows.Next() {
		var i GetProblemsByContestRow
		if err := rows.Scan(
			&i.Problem.ID,
			&i.Problem.OrganizerID,
			&i.Problem.ContestID,
			&i.Problem.Number,
			&i.Problem.HoldColorPrimary,
			&i.Problem.HoldColorSecondary,
			&i.Problem.Name,
			&i.Problem.Description,
			&i.Problem.Points,
			&i.Problem.FlashBonus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTick = `-- name: GetTick :one
SELECT tick.id, tick.organizer_id, tick.contest_id, tick.contender_id, tick.problem_id, tick.flash, tick.timestamp
FROM tick
WHERE id = ?
`

type GetTickRow struct {
	Tick Tick
}

func (q *Queries) GetTick(ctx context.Context, id int32) (GetTickRow, error) {
	row := q.db.QueryRowContext(ctx, getTick, id)
	var i GetTickRow
	err := row.Scan(
		&i.Tick.ID,
		&i.Tick.OrganizerID,
		&i.Tick.ContestID,
		&i.Tick.ContenderID,
		&i.Tick.ProblemID,
		&i.Tick.Flash,
		&i.Tick.Timestamp,
	)
	return i, err
}

const getTicksByContender = `-- name: GetTicksByContender :many
SELECT tick.id, tick.organizer_id, tick.contest_id, tick.contender_id, tick.problem_id, tick.flash, tick.timestamp
FROM tick
WHERE contender_id = ?
`

type GetTicksByContenderRow struct {
	Tick Tick
}

func (q *Queries) GetTicksByContender(ctx context.Context, contenderID int32) ([]GetTicksByContenderRow, error) {
	rows, err := q.db.QueryContext(ctx, getTicksByContender, contenderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTicksByContenderRow
	for rows.Next() {
		var i GetTicksByContenderRow
		if err := rows.Scan(
			&i.Tick.ID,
			&i.Tick.OrganizerID,
			&i.Tick.ContestID,
			&i.Tick.ContenderID,
			&i.Tick.ProblemID,
			&i.Tick.Flash,
			&i.Tick.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicksByContest = `-- name: GetTicksByContest :many
SELECT tick.id, tick.organizer_id, tick.contest_id, tick.contender_id, tick.problem_id, tick.flash, tick.timestamp
FROM tick
WHERE contest_id = ?
`

type GetTicksByContestRow struct {
	Tick Tick
}

func (q *Queries) GetTicksByContest(ctx context.Context, contestID int32) ([]GetTicksByContestRow, error) {
	rows, err := q.db.QueryContext(ctx, getTicksByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTicksByContestRow
	for rows.Next() {
		var i GetTicksByContestRow
		if err := rows.Scan(
			&i.Tick.ID,
			&i.Tick.OrganizerID,
			&i.Tick.ContestID,
			&i.Tick.ContenderID,
			&i.Tick.ProblemID,
			&i.Tick.Flash,
			&i.Tick.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTick = `-- name: InsertTick :execlastid
INSERT INTO
    tick (organizer_id, contest_id, contender_id, problem_id, flash, timestamp)
VALUES
    (?, ?, ?, ?, ?, ?)
`

type InsertTickParams struct {
	OrganizerID int32
	ContestID   int32
	ContenderID int32
	ProblemID   int32
	Flash       bool
	Timestamp   time.Time
}

func (q *Queries) InsertTick(ctx context.Context, arg InsertTickParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertTick,
		arg.OrganizerID,
		arg.ContestID,
		arg.ContenderID,
		arg.ProblemID,
		arg.Flash,
		arg.Timestamp,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const upsertContender = `-- name: UpsertContender :execlastid
INSERT INTO 
	contender (id, organizer_id, contest_id, registration_code, name, club, class_id, entered, disqualified, withdrawn_from_finals)
VALUES 
	(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    organizer_id = VALUES(organizer_id),
    contest_id = VALUES(contest_id),
    registration_code = VALUES(registration_code),
    name = VALUES(name),
    club = VALUES(club),
    class_id = VALUES(class_id),
    entered = VALUES(entered),
    disqualified = VALUES(disqualified),
    withdrawn_from_finals = VALUES(withdrawn_from_finals)
`

type UpsertContenderParams struct {
	ID                  int32
	OrganizerID         int32
	ContestID           int32
	RegistrationCode    string
	Name                sql.NullString
	Club                sql.NullString
	ClassID             sql.NullInt32
	Entered             sql.NullTime
	Disqualified        bool
	WithdrawnFromFinals bool
}

func (q *Queries) UpsertContender(ctx context.Context, arg UpsertContenderParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, upsertContender,
		arg.ID,
		arg.OrganizerID,
		arg.ContestID,
		arg.RegistrationCode,
		arg.Name,
		arg.Club,
		arg.ClassID,
		arg.Entered,
		arg.Disqualified,
		arg.WithdrawnFromFinals,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const upsertScore = `-- name: UpsertScore :exec
INSERT INTO
    score (contender_id, timestamp, score, placement, finalist, rank_order)
VALUES
    (?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    timestamp = VALUES(timestamp),
    score = VALUES(score),
    placement = VALUES(placement),
    finalist = VALUES(finalist),
    rank_order = VALUES(rank_order)
`

type UpsertScoreParams struct {
	ContenderID int32
	Timestamp   time.Time
	Score       int32
	Placement   int32
	Finalist    bool
	RankOrder   int32
}

func (q *Queries) UpsertScore(ctx context.Context, arg UpsertScoreParams) error {
	_, err := q.db.ExecContext(ctx, upsertScore,
		arg.ContenderID,
		arg.Timestamp,
		arg.Score,
		arg.Placement,
		arg.Finalist,
		arg.RankOrder,
	)
	return err
}
