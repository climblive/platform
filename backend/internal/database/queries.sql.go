// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const addUserToOrganizer = `-- name: AddUserToOrganizer :exec
INSERT INTO
    user_organizer (user_id, organizer_id)
VALUES
    (?, ?)
`

type AddUserToOrganizerParams struct {
	UserID      int32
	OrganizerID int32
}

func (q *Queries) AddUserToOrganizer(ctx context.Context, arg AddUserToOrganizerParams) error {
	_, err := q.db.ExecContext(ctx, addUserToOrganizer, arg.UserID, arg.OrganizerID)
	return err
}

const countContenders = `-- name: CountContenders :one
SELECT COUNT(*)
FROM contender
WHERE contest_id = ?
`

func (q *Queries) CountContenders(ctx context.Context, contestID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContenders, contestID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUnlockRequest = `-- name: CreateUnlockRequest :execlastid
INSERT INTO
    unlock_request (contest_id, organizer_id)
VALUES
    (?, ?)
`

type CreateUnlockRequestParams struct {
	ContestID   int32
	OrganizerID int32
}

func (q *Queries) CreateUnlockRequest(ctx context.Context, arg CreateUnlockRequestParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createUnlockRequest, arg.ContestID, arg.OrganizerID)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteCompClass = `-- name: DeleteCompClass :exec
DELETE FROM comp_class
WHERE id = ?
`

func (q *Queries) DeleteCompClass(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteCompClass, id)
	return err
}

const deleteContender = `-- name: DeleteContender :exec
DELETE FROM contender
WHERE id = ?
`

func (q *Queries) DeleteContender(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteContender, id)
	return err
}

const deleteContest = `-- name: DeleteContest :exec
DELETE FROM contest
WHERE id = ?
`

func (q *Queries) DeleteContest(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteContest, id)
	return err
}

const deleteOrganizerInvite = `-- name: DeleteOrganizerInvite :exec
DELETE FROM organizer_invite
WHERE id = ?
`

func (q *Queries) DeleteOrganizerInvite(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizerInvite, id)
	return err
}

const deleteProblem = `-- name: DeleteProblem :exec
DELETE FROM problem
WHERE id = ?
`

func (q *Queries) DeleteProblem(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteProblem, id)
	return err
}

const deleteRaffle = `-- name: DeleteRaffle :exec
DELETE FROM raffle
WHERE id = ?
`

func (q *Queries) DeleteRaffle(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteRaffle, id)
	return err
}

const deleteRaffleWinner = `-- name: DeleteRaffleWinner :exec
DELETE FROM raffle_winner
WHERE id = ?
`

func (q *Queries) DeleteRaffleWinner(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteRaffleWinner, id)
	return err
}

const deleteTick = `-- name: DeleteTick :exec
DELETE
FROM tick
WHERE id = ?
`

func (q *Queries) DeleteTick(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteTick, id)
	return err
}

const getAllContests = `-- name: GetAllContests :many
SELECT contest.id, contest.organizer_id, contest.archived, contest.series_id, contest.name, contest.description, contest.location, contest.qualifying_problems, contest.finalists, contest.info, contest.grace_period, contest.created, contest.evaluation_mode, MIN(cc.time_begin) AS time_begin, MAX(cc.time_end) AS time_end, COUNT(DISTINCT CASE WHEN c.entered IS NOT NULL THEN c.id END) AS registered_contenders
FROM contest
LEFT JOIN comp_class cc ON cc.contest_id = contest.id
LEFT JOIN contender c ON c.contest_id = contest.id
GROUP BY contest.id
`

type GetAllContestsRow struct {
	Contest              Contest
	TimeBegin            interface{}
	TimeEnd              interface{}
	RegisteredContenders int64
}

func (q *Queries) GetAllContests(ctx context.Context) ([]GetAllContestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllContests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllContestsRow
	for rows.Next() {
		var i GetAllContestsRow
		if err := rows.Scan(
			&i.Contest.ID,
			&i.Contest.OrganizerID,
			&i.Contest.Archived,
			&i.Contest.SeriesID,
			&i.Contest.Name,
			&i.Contest.Description,
			&i.Contest.Location,
			&i.Contest.QualifyingProblems,
			&i.Contest.Finalists,
			&i.Contest.Info,
			&i.Contest.GracePeriod,
			&i.Contest.Created,
			&i.Contest.EvaluationMode,
			&i.TimeBegin,
			&i.TimeEnd,
			&i.RegisteredContenders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOrganizers = `-- name: GetAllOrganizers :many
SELECT id, name
FROM organizer
`

func (q *Queries) GetAllOrganizers(ctx context.Context) ([]Organizer, error) {
	rows, err := q.db.QueryContext(ctx, getAllOrganizers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organizer
	for rows.Next() {
		var i Organizer
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompClass = `-- name: GetCompClass :one
SELECT comp_class.id, comp_class.organizer_id, comp_class.contest_id, comp_class.name, comp_class.description, comp_class.color, comp_class.time_begin, comp_class.time_end
FROM comp_class
WHERE id = ?
`

type GetCompClassRow struct {
	CompClass CompClass
}

func (q *Queries) GetCompClass(ctx context.Context, id int32) (GetCompClassRow, error) {
	row := q.db.QueryRowContext(ctx, getCompClass, id)
	var i GetCompClassRow
	err := row.Scan(
		&i.CompClass.ID,
		&i.CompClass.OrganizerID,
		&i.CompClass.ContestID,
		&i.CompClass.Name,
		&i.CompClass.Description,
		&i.CompClass.Color,
		&i.CompClass.TimeBegin,
		&i.CompClass.TimeEnd,
	)
	return i, err
}

const getCompClassesByContest = `-- name: GetCompClassesByContest :many
SELECT comp_class.id, comp_class.organizer_id, comp_class.contest_id, comp_class.name, comp_class.description, comp_class.color, comp_class.time_begin, comp_class.time_end
FROM comp_class
WHERE contest_id = ?
`

type GetCompClassesByContestRow struct {
	CompClass CompClass
}

func (q *Queries) GetCompClassesByContest(ctx context.Context, contestID int32) ([]GetCompClassesByContestRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompClassesByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompClassesByContestRow
	for rows.Next() {
		var i GetCompClassesByContestRow
		if err := rows.Scan(
			&i.CompClass.ID,
			&i.CompClass.OrganizerID,
			&i.CompClass.ContestID,
			&i.CompClass.Name,
			&i.CompClass.Description,
			&i.CompClass.Color,
			&i.CompClass.TimeBegin,
			&i.CompClass.TimeEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContender = `-- name: GetContender :one
SELECT contender.id, contender.organizer_id, contender.contest_id, contender.registration_code, contender.name, contender.class_id, contender.entered, contender.disqualified, contender.withdrawn_from_finals, score.contender_id, score.timestamp, score.score, score.placement, score.finalist, score.rank_order
FROM contender
LEFT JOIN score ON score.contender_id = id
WHERE id = ?
`

type GetContenderRow struct {
	Contender   Contender
	ContenderID sql.NullInt32
	Timestamp   sql.NullTime
	Score       sql.NullInt32
	Placement   sql.NullInt32
	Finalist    sql.NullBool
	RankOrder   sql.NullInt32
}

func (q *Queries) GetContender(ctx context.Context, id int32) (GetContenderRow, error) {
	row := q.db.QueryRowContext(ctx, getContender, id)
	var i GetContenderRow
	err := row.Scan(
		&i.Contender.ID,
		&i.Contender.OrganizerID,
		&i.Contender.ContestID,
		&i.Contender.RegistrationCode,
		&i.Contender.Name,
		&i.Contender.ClassID,
		&i.Contender.Entered,
		&i.Contender.Disqualified,
		&i.Contender.WithdrawnFromFinals,
		&i.ContenderID,
		&i.Timestamp,
		&i.Score,
		&i.Placement,
		&i.Finalist,
		&i.RankOrder,
	)
	return i, err
}

const getContenderByCode = `-- name: GetContenderByCode :one
SELECT contender.id, contender.organizer_id, contender.contest_id, contender.registration_code, contender.name, contender.class_id, contender.entered, contender.disqualified, contender.withdrawn_from_finals, score.contender_id, score.timestamp, score.score, score.placement, score.finalist, score.rank_order
FROM contender
LEFT JOIN score ON score.contender_id = id
WHERE registration_code = ?
`

type GetContenderByCodeRow struct {
	Contender   Contender
	ContenderID sql.NullInt32
	Timestamp   sql.NullTime
	Score       sql.NullInt32
	Placement   sql.NullInt32
	Finalist    sql.NullBool
	RankOrder   sql.NullInt32
}

func (q *Queries) GetContenderByCode(ctx context.Context, registrationCode string) (GetContenderByCodeRow, error) {
	row := q.db.QueryRowContext(ctx, getContenderByCode, registrationCode)
	var i GetContenderByCodeRow
	err := row.Scan(
		&i.Contender.ID,
		&i.Contender.OrganizerID,
		&i.Contender.ContestID,
		&i.Contender.RegistrationCode,
		&i.Contender.Name,
		&i.Contender.ClassID,
		&i.Contender.Entered,
		&i.Contender.Disqualified,
		&i.Contender.WithdrawnFromFinals,
		&i.ContenderID,
		&i.Timestamp,
		&i.Score,
		&i.Placement,
		&i.Finalist,
		&i.RankOrder,
	)
	return i, err
}

const getContendersByCompClass = `-- name: GetContendersByCompClass :many
SELECT contender.id, contender.organizer_id, contender.contest_id, contender.registration_code, contender.name, contender.class_id, contender.entered, contender.disqualified, contender.withdrawn_from_finals, score.contender_id, score.timestamp, score.score, score.placement, score.finalist, score.rank_order
FROM contender
LEFT JOIN score ON score.contender_id = id
WHERE class_id = ?
`

type GetContendersByCompClassRow struct {
	Contender   Contender
	ContenderID sql.NullInt32
	Timestamp   sql.NullTime
	Score       sql.NullInt32
	Placement   sql.NullInt32
	Finalist    sql.NullBool
	RankOrder   sql.NullInt32
}

func (q *Queries) GetContendersByCompClass(ctx context.Context, classID sql.NullInt32) ([]GetContendersByCompClassRow, error) {
	rows, err := q.db.QueryContext(ctx, getContendersByCompClass, classID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContendersByCompClassRow
	for rows.Next() {
		var i GetContendersByCompClassRow
		if err := rows.Scan(
			&i.Contender.ID,
			&i.Contender.OrganizerID,
			&i.Contender.ContestID,
			&i.Contender.RegistrationCode,
			&i.Contender.Name,
			&i.Contender.ClassID,
			&i.Contender.Entered,
			&i.Contender.Disqualified,
			&i.Contender.WithdrawnFromFinals,
			&i.ContenderID,
			&i.Timestamp,
			&i.Score,
			&i.Placement,
			&i.Finalist,
			&i.RankOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContendersByContest = `-- name: GetContendersByContest :many
SELECT contender.id, contender.organizer_id, contender.contest_id, contender.registration_code, contender.name, contender.class_id, contender.entered, contender.disqualified, contender.withdrawn_from_finals, score.contender_id, score.timestamp, score.score, score.placement, score.finalist, score.rank_order
FROM contender
LEFT JOIN score ON score.contender_id = id
WHERE contest_id = ?
`

type GetContendersByContestRow struct {
	Contender   Contender
	ContenderID sql.NullInt32
	Timestamp   sql.NullTime
	Score       sql.NullInt32
	Placement   sql.NullInt32
	Finalist    sql.NullBool
	RankOrder   sql.NullInt32
}

func (q *Queries) GetContendersByContest(ctx context.Context, contestID int32) ([]GetContendersByContestRow, error) {
	rows, err := q.db.QueryContext(ctx, getContendersByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContendersByContestRow
	for rows.Next() {
		var i GetContendersByContestRow
		if err := rows.Scan(
			&i.Contender.ID,
			&i.Contender.OrganizerID,
			&i.Contender.ContestID,
			&i.Contender.RegistrationCode,
			&i.Contender.Name,
			&i.Contender.ClassID,
			&i.Contender.Entered,
			&i.Contender.Disqualified,
			&i.Contender.WithdrawnFromFinals,
			&i.ContenderID,
			&i.Timestamp,
			&i.Score,
			&i.Placement,
			&i.Finalist,
			&i.RankOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContest = `-- name: GetContest :one
SELECT contest.id, contest.organizer_id, contest.archived, contest.series_id, contest.name, contest.description, contest.location, contest.qualifying_problems, contest.finalists, contest.info, contest.grace_period, contest.created, contest.evaluation_mode, MIN(cc.time_begin) AS time_begin, MAX(cc.time_end) AS time_end, COUNT(DISTINCT CASE WHEN c.entered IS NOT NULL THEN c.id END) AS registered_contenders
FROM contest
LEFT JOIN comp_class cc ON cc.contest_id = contest.id
LEFT JOIN contender c ON c.contest_id = contest.id
WHERE contest.id = ?
GROUP BY contest.id
`

type GetContestRow struct {
	Contest              Contest
	TimeBegin            interface{}
	TimeEnd              interface{}
	RegisteredContenders int64
}

func (q *Queries) GetContest(ctx context.Context, id int32) (GetContestRow, error) {
	row := q.db.QueryRowContext(ctx, getContest, id)
	var i GetContestRow
	err := row.Scan(
		&i.Contest.ID,
		&i.Contest.OrganizerID,
		&i.Contest.Archived,
		&i.Contest.SeriesID,
		&i.Contest.Name,
		&i.Contest.Description,
		&i.Contest.Location,
		&i.Contest.QualifyingProblems,
		&i.Contest.Finalists,
		&i.Contest.Info,
		&i.Contest.GracePeriod,
		&i.Contest.Created,
		&i.Contest.EvaluationMode,
		&i.TimeBegin,
		&i.TimeEnd,
		&i.RegisteredContenders,
	)
	return i, err
}

const getContestsByOrganizer = `-- name: GetContestsByOrganizer :many
SELECT contest.id, contest.organizer_id, contest.archived, contest.series_id, contest.name, contest.description, contest.location, contest.qualifying_problems, contest.finalists, contest.info, contest.grace_period, contest.created, contest.evaluation_mode, MIN(cc.time_begin) AS time_begin, MAX(cc.time_end) AS time_end, COUNT(DISTINCT CASE WHEN c.entered IS NOT NULL THEN c.id END) AS registered_contenders
FROM contest
LEFT JOIN comp_class cc ON cc.contest_id = contest.id
LEFT JOIN contender c ON c.contest_id = contest.id
WHERE contest.organizer_id = ?
GROUP BY contest.id
`

type GetContestsByOrganizerRow struct {
	Contest              Contest
	TimeBegin            interface{}
	TimeEnd              interface{}
	RegisteredContenders int64
}

func (q *Queries) GetContestsByOrganizer(ctx context.Context, organizerID int32) ([]GetContestsByOrganizerRow, error) {
	rows, err := q.db.QueryContext(ctx, getContestsByOrganizer, organizerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContestsByOrganizerRow
	for rows.Next() {
		var i GetContestsByOrganizerRow
		if err := rows.Scan(
			&i.Contest.ID,
			&i.Contest.OrganizerID,
			&i.Contest.Archived,
			&i.Contest.SeriesID,
			&i.Contest.Name,
			&i.Contest.Description,
			&i.Contest.Location,
			&i.Contest.QualifyingProblems,
			&i.Contest.Finalists,
			&i.Contest.Info,
			&i.Contest.GracePeriod,
			&i.Contest.Created,
			&i.Contest.EvaluationMode,
			&i.TimeBegin,
			&i.TimeEnd,
			&i.RegisteredContenders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContestsCurrentlyRunningOrByStartTime = `-- name: GetContestsCurrentlyRunningOrByStartTime :many
SELECT
	id, organizer_id, archived, series_id, name, description, location, qualifying_problems, finalists, info, grace_period, created, evaluation_mode, time_begin, time_end
FROM (
    SELECT contest.id, contest.organizer_id, contest.archived, contest.series_id, contest.name, contest.description, contest.location, contest.qualifying_problems, contest.finalists, contest.info, contest.grace_period, contest.created, contest.evaluation_mode, MIN(cc.time_begin) AS time_begin, MAX(cc.time_end) AS time_end
    FROM contest
    JOIN comp_class cc ON cc.contest_id = contest.id
    WHERE archived = FALSE
    GROUP BY contest.id) AS sub
WHERE
    NOW() BETWEEN sub.time_begin AND DATE_ADD(sub.time_end, INTERVAL (sub.grace_period + 15) MINUTE)
	OR sub.time_begin BETWEEN ? AND ?
`

type GetContestsCurrentlyRunningOrByStartTimeParams struct {
	EarliestStartTime time.Time
	LatestStartTime   time.Time
}

type GetContestsCurrentlyRunningOrByStartTimeRow struct {
	ID                 int32
	OrganizerID        int32
	Archived           bool
	SeriesID           sql.NullInt32
	Name               string
	Description        sql.NullString
	Location           sql.NullString
	QualifyingProblems int32
	Finalists          int32
	Info               sql.NullString
	GracePeriod        int32
	Created            time.Time
	EvaluationMode     bool
	TimeBegin          interface{}
	TimeEnd            interface{}
}

func (q *Queries) GetContestsCurrentlyRunningOrByStartTime(ctx context.Context, arg GetContestsCurrentlyRunningOrByStartTimeParams) ([]GetContestsCurrentlyRunningOrByStartTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, getContestsCurrentlyRunningOrByStartTime, arg.EarliestStartTime, arg.LatestStartTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContestsCurrentlyRunningOrByStartTimeRow
	for rows.Next() {
		var i GetContestsCurrentlyRunningOrByStartTimeRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizerID,
			&i.Archived,
			&i.SeriesID,
			&i.Name,
			&i.Description,
			&i.Location,
			&i.QualifyingProblems,
			&i.Finalists,
			&i.Info,
			&i.GracePeriod,
			&i.Created,
			&i.EvaluationMode,
			&i.TimeBegin,
			&i.TimeEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizer = `-- name: GetOrganizer :one
SELECT id, name
FROM organizer
WHERE id = ?
`

func (q *Queries) GetOrganizer(ctx context.Context, id int32) (Organizer, error) {
	row := q.db.QueryRowContext(ctx, getOrganizer, id)
	var i Organizer
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getOrganizerInvite = `-- name: GetOrganizerInvite :one
SELECT organizer_invite.id, organizer_invite.organizer_id, organizer_invite.expires_at, organizer.name
FROM organizer_invite
JOIN organizer ON organizer.id = organizer_invite.organizer_id
WHERE organizer_invite.id = ?
`

type GetOrganizerInviteRow struct {
	OrganizerInvite OrganizerInvite
	Name            string
}

func (q *Queries) GetOrganizerInvite(ctx context.Context, id string) (GetOrganizerInviteRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizerInvite, id)
	var i GetOrganizerInviteRow
	err := row.Scan(
		&i.OrganizerInvite.ID,
		&i.OrganizerInvite.OrganizerID,
		&i.OrganizerInvite.ExpiresAt,
		&i.Name,
	)
	return i, err
}

const getOrganizerInvitesByOrganizer = `-- name: GetOrganizerInvitesByOrganizer :many
SELECT organizer_invite.id, organizer_invite.organizer_id, organizer_invite.expires_at, organizer.name
FROM organizer_invite
JOIN organizer ON organizer.id = organizer_invite.organizer_id
WHERE organizer_id = ?
`

type GetOrganizerInvitesByOrganizerRow struct {
	OrganizerInvite OrganizerInvite
	Name            string
}

func (q *Queries) GetOrganizerInvitesByOrganizer(ctx context.Context, organizerID int32) ([]GetOrganizerInvitesByOrganizerRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrganizerInvitesByOrganizer, organizerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrganizerInvitesByOrganizerRow
	for rows.Next() {
		var i GetOrganizerInvitesByOrganizerRow
		if err := rows.Scan(
			&i.OrganizerInvite.ID,
			&i.OrganizerInvite.OrganizerID,
			&i.OrganizerInvite.ExpiresAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingUnlockRequests = `-- name: GetPendingUnlockRequests :many
SELECT id, contest_id, organizer_id, status, created_at, reviewed_at
FROM unlock_request
WHERE status = 'pending'
ORDER BY created_at ASC
`

func (q *Queries) GetPendingUnlockRequests(ctx context.Context) ([]UnlockRequest, error) {
	rows, err := q.db.QueryContext(ctx, getPendingUnlockRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnlockRequest
	for rows.Next() {
		var i UnlockRequest
		if err := rows.Scan(
			&i.ID,
			&i.ContestID,
			&i.OrganizerID,
			&i.Status,
			&i.CreatedAt,
			&i.ReviewedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblem = `-- name: GetProblem :one
SELECT problem.id, problem.organizer_id, problem.contest_id, problem.number, problem.hold_color_primary, problem.hold_color_secondary, problem.zone_1_enabled, problem.zone_2_enabled, problem.description, problem.points_zone_1, problem.points_zone_2, problem.points_top, problem.flash_bonus
FROM problem
WHERE id = ?
`

type GetProblemRow struct {
	Problem Problem
}

func (q *Queries) GetProblem(ctx context.Context, id int32) (GetProblemRow, error) {
	row := q.db.QueryRowContext(ctx, getProblem, id)
	var i GetProblemRow
	err := row.Scan(
		&i.Problem.ID,
		&i.Problem.OrganizerID,
		&i.Problem.ContestID,
		&i.Problem.Number,
		&i.Problem.HoldColorPrimary,
		&i.Problem.HoldColorSecondary,
		&i.Problem.Zone1Enabled,
		&i.Problem.Zone2Enabled,
		&i.Problem.Description,
		&i.Problem.PointsZone1,
		&i.Problem.PointsZone2,
		&i.Problem.PointsTop,
		&i.Problem.FlashBonus,
	)
	return i, err
}

const getProblemByNumber = `-- name: GetProblemByNumber :one
SELECT problem.id, problem.organizer_id, problem.contest_id, problem.number, problem.hold_color_primary, problem.hold_color_secondary, problem.zone_1_enabled, problem.zone_2_enabled, problem.description, problem.points_zone_1, problem.points_zone_2, problem.points_top, problem.flash_bonus
FROM problem
WHERE contest_id = ? AND number = ?
`

type GetProblemByNumberParams struct {
	ContestID int32
	Number    int32
}

type GetProblemByNumberRow struct {
	Problem Problem
}

func (q *Queries) GetProblemByNumber(ctx context.Context, arg GetProblemByNumberParams) (GetProblemByNumberRow, error) {
	row := q.db.QueryRowContext(ctx, getProblemByNumber, arg.ContestID, arg.Number)
	var i GetProblemByNumberRow
	err := row.Scan(
		&i.Problem.ID,
		&i.Problem.OrganizerID,
		&i.Problem.ContestID,
		&i.Problem.Number,
		&i.Problem.HoldColorPrimary,
		&i.Problem.HoldColorSecondary,
		&i.Problem.Zone1Enabled,
		&i.Problem.Zone2Enabled,
		&i.Problem.Description,
		&i.Problem.PointsZone1,
		&i.Problem.PointsZone2,
		&i.Problem.PointsTop,
		&i.Problem.FlashBonus,
	)
	return i, err
}

const getProblemsByContest = `-- name: GetProblemsByContest :many
SELECT problem.id, problem.organizer_id, problem.contest_id, problem.number, problem.hold_color_primary, problem.hold_color_secondary, problem.zone_1_enabled, problem.zone_2_enabled, problem.description, problem.points_zone_1, problem.points_zone_2, problem.points_top, problem.flash_bonus
FROM problem
WHERE contest_id = ?
`

type GetProblemsByContestRow struct {
	Problem Problem
}

func (q *Queries) GetProblemsByContest(ctx context.Context, contestID int32) ([]GetProblemsByContestRow, error) {
	rows, err := q.db.QueryContext(ctx, getProblemsByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemsByContestRow
	for rows.Next() {
		var i GetProblemsByContestRow
		if err := rows.Scan(
			&i.Problem.ID,
			&i.Problem.OrganizerID,
			&i.Problem.ContestID,
			&i.Problem.Number,
			&i.Problem.HoldColorPrimary,
			&i.Problem.HoldColorSecondary,
			&i.Problem.Zone1Enabled,
			&i.Problem.Zone2Enabled,
			&i.Problem.Description,
			&i.Problem.PointsZone1,
			&i.Problem.PointsZone2,
			&i.Problem.PointsTop,
			&i.Problem.FlashBonus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRaffle = `-- name: GetRaffle :one
SELECT raffle.id, raffle.organizer_id, raffle.contest_id
FROM raffle
WHERE id = ?
`

type GetRaffleRow struct {
	Raffle Raffle
}

func (q *Queries) GetRaffle(ctx context.Context, id int32) (GetRaffleRow, error) {
	row := q.db.QueryRowContext(ctx, getRaffle, id)
	var i GetRaffleRow
	err := row.Scan(&i.Raffle.ID, &i.Raffle.OrganizerID, &i.Raffle.ContestID)
	return i, err
}

const getRaffleWinners = `-- name: GetRaffleWinners :many
SELECT raffle_winner.id, raffle_winner.organizer_id, raffle_winner.raffle_id, raffle_winner.contender_id, raffle_winner.timestamp, contender.name
FROM raffle_winner
JOIN contender ON contender.id = raffle_winner.contender_id
WHERE raffle_id = ?
`

type GetRaffleWinnersRow struct {
	RaffleWinner RaffleWinner
	Name         sql.NullString
}

func (q *Queries) GetRaffleWinners(ctx context.Context, raffleID int32) ([]GetRaffleWinnersRow, error) {
	rows, err := q.db.QueryContext(ctx, getRaffleWinners, raffleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRaffleWinnersRow
	for rows.Next() {
		var i GetRaffleWinnersRow
		if err := rows.Scan(
			&i.RaffleWinner.ID,
			&i.RaffleWinner.OrganizerID,
			&i.RaffleWinner.RaffleID,
			&i.RaffleWinner.ContenderID,
			&i.RaffleWinner.Timestamp,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRafflesByContest = `-- name: GetRafflesByContest :many
SELECT raffle.id, raffle.organizer_id, raffle.contest_id
FROM raffle
WHERE contest_id = ?
`

type GetRafflesByContestRow struct {
	Raffle Raffle
}

func (q *Queries) GetRafflesByContest(ctx context.Context, contestID int32) ([]GetRafflesByContestRow, error) {
	rows, err := q.db.QueryContext(ctx, getRafflesByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRafflesByContestRow
	for rows.Next() {
		var i GetRafflesByContestRow
		if err := rows.Scan(&i.Raffle.ID, &i.Raffle.OrganizerID, &i.Raffle.ContestID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTick = `-- name: GetTick :one
SELECT tick.id, tick.organizer_id, tick.contest_id, tick.contender_id, tick.problem_id, tick.timestamp, tick.zone_1, tick.attempts_zone_1, tick.zone_2, tick.attempts_zone_2, tick.top, tick.attempts_top
FROM tick
WHERE id = ?
`

type GetTickRow struct {
	Tick Tick
}

func (q *Queries) GetTick(ctx context.Context, id int32) (GetTickRow, error) {
	row := q.db.QueryRowContext(ctx, getTick, id)
	var i GetTickRow
	err := row.Scan(
		&i.Tick.ID,
		&i.Tick.OrganizerID,
		&i.Tick.ContestID,
		&i.Tick.ContenderID,
		&i.Tick.ProblemID,
		&i.Tick.Timestamp,
		&i.Tick.Zone1,
		&i.Tick.AttemptsZone1,
		&i.Tick.Zone2,
		&i.Tick.AttemptsZone2,
		&i.Tick.Top,
		&i.Tick.AttemptsTop,
	)
	return i, err
}

const getTicksByContender = `-- name: GetTicksByContender :many
SELECT tick.id, tick.organizer_id, tick.contest_id, tick.contender_id, tick.problem_id, tick.timestamp, tick.zone_1, tick.attempts_zone_1, tick.zone_2, tick.attempts_zone_2, tick.top, tick.attempts_top
FROM tick
WHERE contender_id = ?
`

type GetTicksByContenderRow struct {
	Tick Tick
}

func (q *Queries) GetTicksByContender(ctx context.Context, contenderID int32) ([]GetTicksByContenderRow, error) {
	rows, err := q.db.QueryContext(ctx, getTicksByContender, contenderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTicksByContenderRow
	for rows.Next() {
		var i GetTicksByContenderRow
		if err := rows.Scan(
			&i.Tick.ID,
			&i.Tick.OrganizerID,
			&i.Tick.ContestID,
			&i.Tick.ContenderID,
			&i.Tick.ProblemID,
			&i.Tick.Timestamp,
			&i.Tick.Zone1,
			&i.Tick.AttemptsZone1,
			&i.Tick.Zone2,
			&i.Tick.AttemptsZone2,
			&i.Tick.Top,
			&i.Tick.AttemptsTop,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicksByContest = `-- name: GetTicksByContest :many
SELECT tick.id, tick.organizer_id, tick.contest_id, tick.contender_id, tick.problem_id, tick.timestamp, tick.zone_1, tick.attempts_zone_1, tick.zone_2, tick.attempts_zone_2, tick.top, tick.attempts_top
FROM tick
WHERE contest_id = ?
`

type GetTicksByContestRow struct {
	Tick Tick
}

func (q *Queries) GetTicksByContest(ctx context.Context, contestID int32) ([]GetTicksByContestRow, error) {
	rows, err := q.db.QueryContext(ctx, getTicksByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTicksByContestRow
	for rows.Next() {
		var i GetTicksByContestRow
		if err := rows.Scan(
			&i.Tick.ID,
			&i.Tick.OrganizerID,
			&i.Tick.ContestID,
			&i.Tick.ContenderID,
			&i.Tick.ProblemID,
			&i.Tick.Timestamp,
			&i.Tick.Zone1,
			&i.Tick.AttemptsZone1,
			&i.Tick.Zone2,
			&i.Tick.AttemptsZone2,
			&i.Tick.Top,
			&i.Tick.AttemptsTop,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicksByProblem = `-- name: GetTicksByProblem :many
SELECT tick.id, tick.organizer_id, tick.contest_id, tick.contender_id, tick.problem_id, tick.timestamp, tick.zone_1, tick.attempts_zone_1, tick.zone_2, tick.attempts_zone_2, tick.top, tick.attempts_top
FROM tick
WHERE problem_id = ?
`

type GetTicksByProblemRow struct {
	Tick Tick
}

func (q *Queries) GetTicksByProblem(ctx context.Context, problemID int32) ([]GetTicksByProblemRow, error) {
	rows, err := q.db.QueryContext(ctx, getTicksByProblem, problemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTicksByProblemRow
	for rows.Next() {
		var i GetTicksByProblemRow
		if err := rows.Scan(
			&i.Tick.ID,
			&i.Tick.OrganizerID,
			&i.Tick.ContestID,
			&i.Tick.ContenderID,
			&i.Tick.ProblemID,
			&i.Tick.Timestamp,
			&i.Tick.Zone1,
			&i.Tick.AttemptsZone1,
			&i.Tick.Zone2,
			&i.Tick.AttemptsZone2,
			&i.Tick.Top,
			&i.Tick.AttemptsTop,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnlockRequest = `-- name: GetUnlockRequest :one
SELECT id, contest_id, organizer_id, status, created_at, reviewed_at
FROM unlock_request
WHERE id = ?
`

func (q *Queries) GetUnlockRequest(ctx context.Context, id int32) (UnlockRequest, error) {
	row := q.db.QueryRowContext(ctx, getUnlockRequest, id)
	var i UnlockRequest
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.OrganizerID,
		&i.Status,
		&i.CreatedAt,
		&i.ReviewedAt,
	)
	return i, err
}

const getUnlockRequestsByContest = `-- name: GetUnlockRequestsByContest :many
SELECT id, contest_id, organizer_id, status, created_at, reviewed_at
FROM unlock_request
WHERE contest_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetUnlockRequestsByContest(ctx context.Context, contestID int32) ([]UnlockRequest, error) {
	rows, err := q.db.QueryContext(ctx, getUnlockRequestsByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnlockRequest
	for rows.Next() {
		var i UnlockRequest
		if err := rows.Scan(
			&i.ID,
			&i.ContestID,
			&i.OrganizerID,
			&i.Status,
			&i.CreatedAt,
			&i.ReviewedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnlockRequestsByOrganizer = `-- name: GetUnlockRequestsByOrganizer :many
SELECT id, contest_id, organizer_id, status, created_at, reviewed_at
FROM unlock_request
WHERE organizer_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetUnlockRequestsByOrganizer(ctx context.Context, organizerID int32) ([]UnlockRequest, error) {
	rows, err := q.db.QueryContext(ctx, getUnlockRequestsByOrganizer, organizerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnlockRequest
	for rows.Next() {
		var i UnlockRequest
		if err := rows.Scan(
			&i.ID,
			&i.ContestID,
			&i.OrganizerID,
			&i.Status,
			&i.CreatedAt,
			&i.ReviewedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByUsername = `-- name: GetUserByUsername :many
SELECT user.id, user.username, user.admin, organizer.id, organizer.name
FROM user
LEFT JOIN user_organizer uo ON uo.user_id = user.id
LEFT JOIN organizer ON organizer.id = uo.organizer_id
WHERE username = ?
`

type GetUserByUsernameRow struct {
	User      User
	Organizer Organizer
}

func (q *Queries) GetUserByUsername(ctx context.Context, username string) ([]GetUserByUsernameRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserByUsername, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserByUsernameRow
	for rows.Next() {
		var i GetUserByUsernameRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Username,
			&i.User.Admin,
			&i.Organizer.ID,
			&i.Organizer.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByOrganizer = `-- name: GetUsersByOrganizer :many
SELECT user.id, user.username, user.admin
FROM user
LEFT JOIN user_organizer uo ON uo.user_id = user.id
WHERE uo.organizer_id = ?
`

type GetUsersByOrganizerRow struct {
	User User
}

func (q *Queries) GetUsersByOrganizer(ctx context.Context, organizerID int32) ([]GetUsersByOrganizerRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByOrganizer, organizerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByOrganizerRow
	for rows.Next() {
		var i GetUsersByOrganizerRow
		if err := rows.Scan(&i.User.ID, &i.User.Username, &i.User.Admin); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasApprovedUnlockRequest = `-- name: HasApprovedUnlockRequest :one
SELECT COUNT(*) > 0 as has_approved
FROM unlock_request
WHERE organizer_id = ? AND status = 'approved'
`

func (q *Queries) HasApprovedUnlockRequest(ctx context.Context, organizerID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasApprovedUnlockRequest, organizerID)
	var has_approved bool
	err := row.Scan(&has_approved)
	return has_approved, err
}

const insertOrganizerInvite = `-- name: InsertOrganizerInvite :exec
INSERT INTO
    organizer_invite (id, organizer_id, expires_at)
VALUES
    (?, ?, ?)
`

type InsertOrganizerInviteParams struct {
	ID          string
	OrganizerID int32
	ExpiresAt   time.Time
}

func (q *Queries) InsertOrganizerInvite(ctx context.Context, arg InsertOrganizerInviteParams) error {
	_, err := q.db.ExecContext(ctx, insertOrganizerInvite, arg.ID, arg.OrganizerID, arg.ExpiresAt)
	return err
}

const insertTick = `-- name: InsertTick :execlastid
INSERT INTO
    tick (organizer_id, contest_id, contender_id, problem_id, timestamp, top, attempts_top, zone_1, attempts_zone_1, zone_2, attempts_zone_2)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertTickParams struct {
	OrganizerID   int32
	ContestID     int32
	ContenderID   int32
	ProblemID     int32
	Timestamp     time.Time
	Top           bool
	AttemptsTop   int32
	Zone1         bool
	AttemptsZone1 int32
	Zone2         bool
	AttemptsZone2 int32
}

func (q *Queries) InsertTick(ctx context.Context, arg InsertTickParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertTick,
		arg.OrganizerID,
		arg.ContestID,
		arg.ContenderID,
		arg.ProblemID,
		arg.Timestamp,
		arg.Top,
		arg.AttemptsTop,
		arg.Zone1,
		arg.AttemptsZone1,
		arg.Zone2,
		arg.AttemptsZone2,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const updateUnlockRequestStatus = `-- name: UpdateUnlockRequestStatus :exec
UPDATE unlock_request
SET 
    status = ?,
    reviewed_at = ?
WHERE id = ?
`

type UpdateUnlockRequestStatusParams struct {
	Status     UnlockRequestStatus
	ReviewedAt sql.NullTime
	ID         int32
}

func (q *Queries) UpdateUnlockRequestStatus(ctx context.Context, arg UpdateUnlockRequestStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateUnlockRequestStatus, arg.Status, arg.ReviewedAt, arg.ID)
	return err
}

const upsertCompClass = `-- name: UpsertCompClass :execlastid
INSERT INTO 
	comp_class (id, organizer_id, contest_id, name, description, color, time_begin, time_end)
VALUES 
	(?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    organizer_id = VALUES(organizer_id),
    contest_id = VALUES(contest_id),
    name = VALUES(name),
    description = VALUES(description),
    color = VALUES(color),
    time_begin = VALUES(time_begin),
    time_end = VALUES(time_end)
`

type UpsertCompClassParams struct {
	ID          int32
	OrganizerID int32
	ContestID   int32
	Name        string
	Description sql.NullString
	Color       sql.NullString
	TimeBegin   time.Time
	TimeEnd     time.Time
}

func (q *Queries) UpsertCompClass(ctx context.Context, arg UpsertCompClassParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, upsertCompClass,
		arg.ID,
		arg.OrganizerID,
		arg.ContestID,
		arg.Name,
		arg.Description,
		arg.Color,
		arg.TimeBegin,
		arg.TimeEnd,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const upsertContender = `-- name: UpsertContender :execlastid
INSERT INTO 
	contender (id, organizer_id, contest_id, registration_code, name, class_id, entered, disqualified, withdrawn_from_finals)
VALUES 
	(?, ?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    organizer_id = VALUES(organizer_id),
    contest_id = VALUES(contest_id),
    registration_code = VALUES(registration_code),
    name = VALUES(name),
    class_id = VALUES(class_id),
    entered = VALUES(entered),
    disqualified = VALUES(disqualified),
    withdrawn_from_finals = VALUES(withdrawn_from_finals)
`

type UpsertContenderParams struct {
	ID                  int32
	OrganizerID         int32
	ContestID           int32
	RegistrationCode    string
	Name                sql.NullString
	ClassID             sql.NullInt32
	Entered             sql.NullTime
	Disqualified        bool
	WithdrawnFromFinals bool
}

func (q *Queries) UpsertContender(ctx context.Context, arg UpsertContenderParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, upsertContender,
		arg.ID,
		arg.OrganizerID,
		arg.ContestID,
		arg.RegistrationCode,
		arg.Name,
		arg.ClassID,
		arg.Entered,
		arg.Disqualified,
		arg.WithdrawnFromFinals,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const upsertContest = `-- name: UpsertContest :execlastid
INSERT INTO 
	contest (id, organizer_id, archived, series_id, name, description, location, qualifying_problems, finalists, info, grace_period, created, evaluation_mode)
VALUES 
	(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    organizer_id = VALUES(organizer_id),
    archived = VALUES(archived),
    series_id = VALUES(series_id),
    name = VALUES(name),
    description = VALUES(description),
    location = VALUES(location),
    qualifying_problems = VALUES(qualifying_problems),
    finalists = VALUES(finalists),
    info = VALUES(info),
    grace_period = VALUES(grace_period),
    created = VALUES(created),
    evaluation_mode = VALUES(evaluation_mode)
`

type UpsertContestParams struct {
	ID                 int32
	OrganizerID        int32
	Archived           bool
	SeriesID           sql.NullInt32
	Name               string
	Description        sql.NullString
	Location           sql.NullString
	QualifyingProblems int32
	Finalists          int32
	Info               sql.NullString
	GracePeriod        int32
	Created            time.Time
	EvaluationMode     bool
}

func (q *Queries) UpsertContest(ctx context.Context, arg UpsertContestParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, upsertContest,
		arg.ID,
		arg.OrganizerID,
		arg.Archived,
		arg.SeriesID,
		arg.Name,
		arg.Description,
		arg.Location,
		arg.QualifyingProblems,
		arg.Finalists,
		arg.Info,
		arg.GracePeriod,
		arg.Created,
		arg.EvaluationMode,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const upsertOrganizer = `-- name: UpsertOrganizer :execlastid
INSERT INTO
    organizer (id, name)
VALUES
    (?, ?)
ON DUPLICATE KEY UPDATE
    name = VALUES(name)
`

type UpsertOrganizerParams struct {
	ID   int32
	Name string
}

func (q *Queries) UpsertOrganizer(ctx context.Context, arg UpsertOrganizerParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, upsertOrganizer, arg.ID, arg.Name)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const upsertProblem = `-- name: UpsertProblem :execlastid
INSERT INTO 
	problem (id, organizer_id, contest_id, number, hold_color_primary, hold_color_secondary, zone_1_enabled, zone_2_enabled, description, points_zone_1, points_zone_2, points_top, flash_bonus)
VALUES 
	(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    organizer_id = VALUES(organizer_id),
    contest_id = VALUES(contest_id),
    number = VALUES(number),
    hold_color_primary = VALUES(hold_color_primary),
    hold_color_secondary = VALUES(hold_color_secondary),
    zone_1_enabled = VALUES(zone_1_enabled),
    zone_2_enabled = VALUES(zone_2_enabled),
    description = VALUES(description),
    points_zone_1 = VALUES(points_zone_1),
    points_zone_2 = VALUES(points_zone_2),
    points_top = VALUES(points_top),
    flash_bonus = VALUES(flash_bonus)
`

type UpsertProblemParams struct {
	ID                 int32
	OrganizerID        int32
	ContestID          int32
	Number             int32
	HoldColorPrimary   string
	HoldColorSecondary sql.NullString
	Zone1Enabled       bool
	Zone2Enabled       bool
	Description        sql.NullString
	PointsZone1        sql.NullInt32
	PointsZone2        sql.NullInt32
	PointsTop          int32
	FlashBonus         sql.NullInt32
}

func (q *Queries) UpsertProblem(ctx context.Context, arg UpsertProblemParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, upsertProblem,
		arg.ID,
		arg.OrganizerID,
		arg.ContestID,
		arg.Number,
		arg.HoldColorPrimary,
		arg.HoldColorSecondary,
		arg.Zone1Enabled,
		arg.Zone2Enabled,
		arg.Description,
		arg.PointsZone1,
		arg.PointsZone2,
		arg.PointsTop,
		arg.FlashBonus,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const upsertRaffle = `-- name: UpsertRaffle :execlastid
INSERT INTO
    raffle (id, organizer_id, contest_id)
VALUES
    (?, ?, ?)
ON DUPLICATE KEY UPDATE
    organizer_id = VALUES(organizer_id),
    contest_id = VALUES(contest_id)
`

type UpsertRaffleParams struct {
	ID          int32
	OrganizerID int32
	ContestID   int32
}

func (q *Queries) UpsertRaffle(ctx context.Context, arg UpsertRaffleParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, upsertRaffle, arg.ID, arg.OrganizerID, arg.ContestID)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const upsertRaffleWinner = `-- name: UpsertRaffleWinner :execlastid
INSERT INTO
    raffle_winner (id, organizer_id, raffle_id, contender_id, timestamp)
VALUES
    (?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    organizer_id = VALUES(organizer_id),
    raffle_id = VALUES(raffle_id),
    contender_id = VALUES(contender_id),
    timestamp = VALUES(timestamp)
`

type UpsertRaffleWinnerParams struct {
	ID          int32
	OrganizerID int32
	RaffleID    int32
	ContenderID int32
	Timestamp   time.Time
}

func (q *Queries) UpsertRaffleWinner(ctx context.Context, arg UpsertRaffleWinnerParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, upsertRaffleWinner,
		arg.ID,
		arg.OrganizerID,
		arg.RaffleID,
		arg.ContenderID,
		arg.Timestamp,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const upsertScore = `-- name: UpsertScore :exec
INSERT INTO
    score (contender_id, timestamp, score, placement, finalist, rank_order)
VALUES
    (?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    timestamp = VALUES(timestamp),
    score = VALUES(score),
    placement = VALUES(placement),
    finalist = VALUES(finalist),
    rank_order = VALUES(rank_order)
`

type UpsertScoreParams struct {
	ContenderID int32
	Timestamp   time.Time
	Score       int32
	Placement   int32
	Finalist    bool
	RankOrder   int32
}

func (q *Queries) UpsertScore(ctx context.Context, arg UpsertScoreParams) error {
	_, err := q.db.ExecContext(ctx, upsertScore,
		arg.ContenderID,
		arg.Timestamp,
		arg.Score,
		arg.Placement,
		arg.Finalist,
		arg.RankOrder,
	)
	return err
}

const upsertUser = `-- name: UpsertUser :execlastid
INSERT INTO
    user (id, username, admin)
VALUES
    (?, ?, ?)
ON DUPLICATE KEY UPDATE
    username = VALUES(username),
    admin = VALUES(admin)
`

type UpsertUserParams struct {
	ID       int32
	Username string
	Admin    bool
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, upsertUser, arg.ID, arg.Username, arg.Admin)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}
